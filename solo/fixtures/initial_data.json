[{"pk": 1, "model": "solo.post", "fields": {"body": "I've been using Tastypie recently to develop multiple json APIs. It's a very useful library and well thought out. In this particular case, I wanted to be able to create and serve a temporary resource. After it had been retrieved, I wanted to make it unavailable and trash it. There were two parts required get this done:\r\n\r\n1. A cache to store the resource and delete it upon retrieval\r\n2. Hooking into the Tastypie Resource class for creation and retrieval\r\n\r\n# Celery + Redis\r\nI was already using a combination of celery and redis for asynchronous task execution for this particular application. Since celery is designed to discard task results after retrieval by default, it was the perfect fit. You could just as soon use a different celery backend, but redis is the most painless to install and configure.\r\n\r\nHere's an example task: \r\n\r\n<script src=\"https://gist.github.com/1625609.js?file=gistfile1.py\"></script>\r\n\r\nIn this case we just performed some simple calculations and returned a dictionary. Setting the return value as a dictionary will make it easier to attach to the Tastypie Bundle.\r\n\r\n# Tastypie Resource\r\nThe trick here is to access the asynchronous celery results in the right spot. Additionally we use the celery task_id as the Tastypie primary key for the URI access.\r\n\r\n<script src=\"https://gist.github.com/1625633.js?file=gistfile1.py\"></script>\r\n\r\nFirst notice that you have to use temp_resource.delay for the *object_class*. It will not function if you just hand it the task name. The .delay() method instantiates the actual BaseTask class that Tastypie requires.\r\n\r\nFor sanity, I've opted to use the celery task id as the Tastypie Resource URI. The *get_resource_uri()* method pulls the task_id off of the Task.result object for use in the api url. This means the location will be something like *http://www.mysite.com/api/v1/temp_resource/ada93452-8bc1-4e38-88aa-8dfb866b398c/*.\r\n\r\nWhen we create the temporary resource with *obj_create*, we simply pull keyword arguments from the POST for use in executing our task. Later, to access the temporary resource, we need to use the AsyncResult method to access the task result by its task id:\r\n\r\n    #!python\r\n    result = temp_resource.AsyncResult(kwargs['pk'])\r\n\r\nRemember that primary key (pk) is how Tastypie interprets the key from the URI Get request.\r\n\r\nLast but not least, we need to make sure that we actually add the task results to the resource data when it's retrieved. For this we have to override the *full_dehydrate* method. First we need to retrieve the task results with the result.get() method:\r\n\r\n    #!python\r\n    temp_resource_info = bundle.obj.get()\r\n\r\nRemember that this is asynchronous, and the get() method will wait until the results are ready. Alternatively you could test if the result was ready and if not return a pending status message. After retrieving the data, simple cycle over the items and add them to the bundle.\r\n\r\n# Conclusion\r\nYou should now have access to one-time use resources through the Tastypie api. After you successfully retrieve the data once, celery should no longer make the information available. ", "slug": "single-retrieval-resources-with-tastypie-and-redis", "pubdate": "2012-01-17 23:16:56", "title": "Single Retrieval Resources with Tastypie and Redis", "tagline": "tagline here", "modified": "2012-01-17 23:42:35", "body_html": "<p>I've been using Tastypie recently to develop multiple json APIs. It's a very useful library and well thought out. In this particular case, I wanted to be able to create and serve a temporary resource. After it had been retrieved, I wanted to make it unavailable and trash it. There were two parts required get this done:</p>\n<ol>\n<li>A cache to store the resource and delete it upon retrieval</li>\n<li>Hooking into the Tastypie Resource class for creation and retrieval</li>\n</ol>\n<h1>Celery + Redis</h1>\n<p>I was already using a combination of celery and redis for asynchronous task execution for this particular application. Since celery is designed to discard task results after retrieval by default, it was the perfect fit. You could just as soon use a different celery backend, but redis is the most painless to install and configure.</p>\n<p>Here's an example task: </p>\n<script src=\"https://gist.github.com/1625609.js?file=gistfile1.py\"></script>\n\n<p>In this case we just performed some simple calculations and returned a dictionary. Setting the return value as a dictionary will make it easier to attach to the Tastypie Bundle.</p>\n<h1>Tastypie Resource</h1>\n<p>The trick here is to access the asynchronous celery results in the right spot. Additionally we use the celery task_id as the Tastypie primary key for the URI access.</p>\n<script src=\"https://gist.github.com/1625633.js?file=gistfile1.py\"></script>\n\n<p>First notice that you have to use temp_resource.delay for the <em>object_class</em>. It will not function if you just hand it the task name. The .delay() method instantiates the actual BaseTask class that Tastypie requires.</p>\n<p>For sanity, I've opted to use the celery task id as the Tastypie Resource URI. The <em>get_resource_uri()</em> method pulls the task_id off of the Task.result object for use in the api url. This means the location will be something like <em>http://www.mysite.com/api/v1/temp_resource/ada93452-8bc1-4e38-88aa-8dfb866b398c/</em>.</p>\n<p>When we create the temporary resource with <em>obj_create</em>, we simply pull keyword arguments from the POST for use in executing our task. Later, to access the temporary resource, we need to use the AsyncResult method to access the task result by its task id:</p>\n<pre class=\"codehilite\"><code class=\"language-python linenums\">result = temp_resource.AsyncResult(kwargs['pk'])</code></pre>\n\n\n<p>Remember that primary key (pk) is how Tastypie interprets the key from the URI Get request.</p>\n<p>Last but not least, we need to make sure that we actually add the task results to the resource data when it's retrieved. For this we have to override the <em>full_dehydrate</em> method. First we need to retrieve the task results with the result.get() method:</p>\n<pre class=\"codehilite\"><code class=\"language-python linenums\">temp_resource_info = bundle.obj.get()</code></pre>\n\n\n<p>Remember that this is asynchronous, and the get() method will wait until the results are ready. Alternatively you could test if the result was ready and if not return a pending status message. After retrieving the data, simple cycle over the items and add them to the bundle.</p>\n<h1>Conclusion</h1>\n<p>You should now have access to one-time use resources through the Tastypie api. After you successfully retrieve the data once, celery should no longer make the information available. </p>", "public": true}}]